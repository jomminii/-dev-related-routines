# [[토프링] 1장 오브젝트와 의존관계](블로그주소 예정)

>토비의 스프링 스터디를 진행하며 작성한 글 입니다. 대부분 토비의 스프링을 참조하고 있습니다.
- [스터디 github](https://github.com/jomminii/toby-spring-study)
- [샘플 코드](https://github.com/jomminii/toby-spring-sample-code)

<br>

# 1.1 초난감 DAO
> DAO(Data Access Object) : DB 를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트

오브젝트와 의존관계에 대해 알아보기 위해 초난감 DAO 라는 예시를 만들어 보겠습니다. 초난감 DAO 는 실무에서는 쓰이지 않을 문제가 많은 코드인데요, 이를 구현하기 위한 코드들은 아래와 같습니다.

먼저 사용자 정보(id, name, password)를 저장할 `User` 클래스를 만듭니다.

```java
public class User {

    String id;
    String name;
    String password;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

그리고 실제로 `User` 오브젝트의 정보를 담을 수 있는 DB 테이블을 생성합니다.
```sql
create table users (
	id varchar(10) primary key,
	name varchar(20) not null,
	password varchar(10) not null
);

```

<br>

이번에는 사용자 정보를 DB에 넣고 관리할 수 있는 `UserDao`를 만들어보겠습니다.

DB에 값을 저장하거나 조회하려면 아래와 같은 프로세스를 거쳐야합니다.
- 드라이버 로드
- Connection 가져오기
- SQL을 담은 statement 작성
- 만들어진 statement 실행
- 조회의 경우 불러온 값을 저장할 오브젝트에 담아 전달
- Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 닫아주기
- 예외 처리

이렇게 하면 안된다는걸 알지만 초난감 DAO를 만들기 위해 하나의 DAO 안에 이 프로세스를 모두 담아보겠습니다.

```java
public class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("org.mariadb.jdbc.Driver");

        Connection c = DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/test",
            "testId",
            "password"
        );

        PreparedStatement ps = c.prepareStatement(
            "insert into users(id, name, password) values(?,?,?)"
        );
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();

    }

    public User get(String id) throws SQLException, ClassNotFoundException {
        Class.forName("org.mariadb.jdbc.Driver");

        Connection c = DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/test",
            "testId",
            "password"
        );

        PreparedStatement ps = c.prepareStatement(
            "select * from users where id = ?"
        );

        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
}
```

코드를 작성하고 보니 중복도 많고, `UserDao`의 책임이 아닌 것처럼 보이는 것들도 많이 담아져 있습니다.

<br>

일단 작성한 코드가 정상적으로 작동하는지 확인해보겠습니다.
간단히 테스트를 위한 클래스를 만들고 `main()`을 통해 기능이 잘 작동하는지 확인해봤습니다.

```java
public class TestMain {

    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        UserDao dao = new UserDao();

        User user = new User();
        user.setId("testId");
        user.setName("테스트아이디");
        user.setPassword("password");

        dao.add(user);

        System.out.println(user.getId() + " 등록 성공");

        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());
        System.out.println(user2.getId() + " 조회 성공");
    }
}

```

<br>

원하는대로 등록도 잘되고 조회도 잘 되었습니다.
하지만 기능만 잘된다고 끝이 아니겠죠. 이제 이 초난감 DAO 를 조금씩 개선시켜 보겠습니다.

```bash
testId 등록 성공
테스트아이디
password
testId 조회 성공

Process finished with exit code 0
```

# 1.2 DAO의 분리

모든 것은 변합니다. 코드도 마찬가지죠.
한 번 작성하고 잘 작동하면 끝날 것 같지만 코드의 구조가 변할 수도 요구사항이 변할 수도 있습니다.
객체지향 설계와 프로그래밍이 초기에 보다 더 많은 작업을 요구하는 이유는 객체지향 기술 자체가 지니는 변화에 효과적으로 대처할 수 있다는 기술적 특징 때문인데요. 어떻게 하면 미래의 변화에 효과적으로 대처할 수 있게 설계를 할 수 있을까요?

분리와 확장을 고려한 설계가 답 입니다.

프로그래밍의 기초 개념 중 관심사의 분리라는게 있는데, 이를 객체지향에 적용해보면 관심이 같은 것끼리는 하나의 객체 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 떨어뜨려 서로 영향을 주지 않도록 분리하는 것이라고 생각할 수 있습니다.

## 커넥션 만들기 추출
### UserDao의 관심사항
지금 만들어져 있는 `UserDao`를 보면 아주 바빠보입니다. `DB Connection`도 만들어야하고, 쿼리도 만들어서 DB에 날려줘야하고, 결과 값을 가공해서 요청한 클라이언트에게 전달도 해줘야합니다.

개중에 또 문제가 되는 부분은 `DB Connection`을 연결하는 부분을 `add`와 `get` 메서드가 모두 사용하면서 중복이 일어나고 있다는 점 입니다.

지금처럼 코드가 많지 않으면 그나마 낫지만 실무에서는 수십 수백군데에서 사용할 수 있는 로직인데요, 모두 중복으로 사용하다가 코드에 수정이라도 생긴다고 생각하면... 끔찍합니다.

이걸 보듯이 하나의 관심사(`DB Connection`)가 여러군데에서 중복되어 있고 다른 관심의 대상과 얽혀있으면, 변경이 일어날 때 끔찍한 일이 발생할 수 있습니다.

### 중복 코드의 메소드 추출
중복되어 사용되고 있는 `DB Connection` 로직을 메소드로 추출해서 관심사를 집중 시켜 보겠습니다.

```java
public class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
		...
    }

    public User get(String id) throws SQLException, ClassNotFoundException {
        Connection c = getConnection();

		...
    }

    private static Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName("org.mariadb.jdbc.Driver");

        return DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/test",
            "testId",
            "password"
        );
    }
}
```

로직을 `DB Connection`에 집중한 관심사로 모아 새로운 메소드를 만들고, 기존 로직에 넣었습니다. 이제 `DB Connection`의 관심에 대한 변화가 생기면 다른 코드에는 영향을 주지 않고 관심이 집중된 코드만 수정하면 됩니다. 관심이 독립적으로 독립하면서 변화에 대응하기 쉬운 코드가 되었습니다.

### 변경사항에 대한 검증
이렇게 리팩토링을 한 후에 `main()`을 통해 검증을 해보면 잘 작동하는걸 볼 수 있습니다. 방금 한 작업은 기능상에는 어떠한 영향도 주지 않았지만 변화에 좀 더 손쉽게 대응할 수 있는 보다 더 깔끔한 코드가 되었습니다.


## 커넥션 만들기의 독립

이번에는 이런 상황을 가정해보겠습니다. `UserDao`의 인기가 너무 많아져서 다른 곳에서도 `UserDao`를 가져다 쓰고 싶어하고 있습니다. 그런데 `DB Connection` 로직만은 외부에 공개하고 싶지가 않은거죠.

이런 경우에는 `UserDao`를 추상 클래스로 만들고 `getConnection`을 추상 메소드로 선언해서, 외부에서 `UserDao`를 상속받게 한 뒤 각자 입맛에 맞게 `getConnection`을 구현하도록 하는 방법을 사용할 수 있습니다. 아예 데이터베이스 연결이라는 관심사 자체를 외부(추상 클래스를 상속한 서브클래스)로 독립시켜버리는거죠.


```java
public abstract class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
		...
    }

    public User get(String id) throws SQLException, ClassNotFoundException {
        Connection c = getConnection();
		...
    }
    public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}


```

<br>

추상 클래스인 `UserDao`를 상속 받아서 `getConnection`만 독립적으로 구현했습니다. 이 방식을 이용하면 `UserDao`에서 코드를 수정할 필요가 없어지고, 새로운 `DB Connection` 방식이 필요하다면 손쉽게 상속 받아서 새롭게 확장하여 구현하면 됩니다.

```java
public class NUserDao extends UserDao {

    @Override
    public Connection getConnection() throws ClassNotFoundException, SQLException {
        // 독립된 DB Connection 구현
        System.out.println("독립적으로 구현!!!");
        
        Class.forName("org.mariadb.jdbc.Driver");

        return DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/test",
            "testId",
            "password"
        );
    }
}

```

이렇게 슈퍼클래스에 기본적인 로직의 흐름을 짜두고, 기능의 일부를 추상 메소드나 오버라이딩이 가능한 메소드 등으로 만든 뒤 서브 클래스에서 필요에 맞게 구현하도록 하는 디자인 패턴을 `템플릿 메소드 패턴` 이라고 합니다.

그리고 서브 클래스의 `getConnection` 처럼 어떤 클래스의 오브젝트를 어떻게 생성할지에 대한 방법을 결정하게 하는 디자인 패턴을 `팩토리 메소드 패턴` 이라고 합니다.

이런 방식으로 서브 클래스에게 구현을 넘기게 되면 `UserDao`는 `DB Connection`에 대해 `Connection` 인터페이스 타입의 오브젝트라는 것 외에는 관심을 두지 않고, 그저 `Connection` 인터페이스에 정의된 메소드를 사용할 뿐 입니다.

그리고 각 서브 클래스는 `Connection` 을 어떤식으로 제공하는지에 관심을 가지고 있는거죠.

이렇게 관심사를 좀 더 분리해봤습니다.

보다 더 깔끔해졌지만 이 방식에도 단점이 있습니다. 우리는 상속을 사용하면서 관심사를 분리했는데, 자바의 클래스는 다중상속을 허용하지 않습니다. 이미 다른 슈퍼클래스를 상속했을 수도 있고 추후에 상속할 가능성도 없지 않은데, 단지 `Connection`을 구현하기 위해 상속을 써먹기에는 아쉬움이 많습니다.

뿐만 아니라 상속관계라는건 어쩔 수 없이 긴밀한 관계를 유지할 수 밖에 없는데요, 서브 클래스는 슈퍼 클래스의 기능을 직접 사용할 수 있기 때문에 슈퍼 클래스에서 변경이 생기면 서브 클래스에도 영향을 끼칠 수 있습니다. 서브 클래스가 많다면 각각의 서브 클래스들을 다 변경해줘야 할 수도 있고... 어디서 많이 본 상황이 펼쳐지죠?

그리고 새로 만든 `DB Connection` 기능을 다른데서 사용할 수 없는 것도 문제가 됩니다. 각자의 방식대로 구헌은 했다지만 동일한 방식으로 `DB Connection` 을 사용할 경우 이를 갖다쓰지 못하고 계속 새로 구현해야하는 경우도 생길 수 있습니다.





