# [[토프링] 1장 오브젝트와 의존관계](블로그주소 예정)

>토비의 스프링 스터디를 진행하며 작성한 글 입니다. 대부분 토비의 스프링을 참조하고 있습니다.
- [스터디 github](https://github.com/jomminii/toby-spring-study)
- [샘플 코드](https://github.com/jomminii/toby-spring-sample-code)

<br>

# 1.1 초난감 DAO
> DAO(Data Access Object) : DB 를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트

오브젝트와 의존관계에 대해 알아보기 위해 초난감 DAO 라는 예시를 만들어 보겠습니다. 초난감 DAO 는 실무에서는 쓰이지 않을 문제가 많은 코드인데요, 이를 구현하기 위한 코드들은 아래와 같습니다.

먼저 사용자 정보(id, name, password)를 저장할 `User` 클래스를 만듭니다.

```java
public class User {

    String id;
    String name;
    String password;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}
```

그리고 실제로 `User` 오브젝트의 정보를 담을 수 있는 DB 테이블을 생성합니다.
```sql
create table users (
	id varchar(10) primary key,
	name varchar(20) not null,
	password varchar(10) not null
);

```

<br>

이번에는 사용자 정보를 DB에 넣고 관리할 수 있는 `UserDao`를 만들어보겠습니다.

DB에 값을 저장하거나 조회하려면 아래와 같은 프로세스를 거쳐야합니다.
- 드라이버 로드
- Connection 가져오기
- SQL을 담은 statement 작성
- 만들어진 statement 실행
- 조회의 경우 불러온 값을 저장할 오브젝트에 담아 전달
- Connection, Statement, ResultSet 같은 리소스는 작업을 마친 후 닫아주기
- 예외 처리

이렇게 하면 안된다는걸 알지만 초난감 DAO를 만들기 위해 하나의 DAO 안에 이 프로세스를 모두 담아보겠습니다.

```java
public class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("org.mariadb.jdbc.Driver");

        Connection c = DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/test",
            "testId",
            "password"
        );

        PreparedStatement ps = c.prepareStatement(
            "insert into users(id, name, password) values(?,?,?)"
        );
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();

    }

    public User get(String id) throws SQLException, ClassNotFoundException {
        Class.forName("org.mariadb.jdbc.Driver");

        Connection c = DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/test",
            "testId",
            "password"
        );

        PreparedStatement ps = c.prepareStatement(
            "select * from users where id = ?"
        );

        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
}
```

코드를 작성하고 보니 중복도 많고, `UserDao`의 책임이 아닌 것처럼 보이는 것들도 많이 담아져 있습니다.

<br>

일단 작성한 코드가 정상적으로 작동하는지 확인해보겠습니다.
간단히 테스트를 위한 클래스를 만들고 `main()`을 통해 기능이 잘 작동하는지 확인해봤습니다.

```java
public class TestMain {

    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        UserDao dao = new UserDao();

        User user = new User();
        user.setId("testId");
        user.setName("테스트아이디");
        user.setPassword("password");

        dao.add(user);

        System.out.println(user.getId() + " 등록 성공");

        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());
        System.out.println(user2.getId() + " 조회 성공");
    }
}

```

<br>

원하는대로 등록도 잘되고 조회도 잘 되었습니다.
하지만 기능만 잘된다고 끝이 아니겠죠. 이제 이 초난감 DAO 를 조금씩 개선시켜 보겠습니다.

```bash
testId 등록 성공
테스트아이디
password
testId 조회 성공

Process finished with exit code 0
```

# 1.2 DAO의 분리

모든 것은 변합니다. 코드도 마찬가지죠.
한 번 작성하고 잘 작동하면 끝날 것 같지만 코드의 구조가 변할 수도 요구사항이 변할 수도 있습니다.
객체지향 설계와 프로그래밍이 초기에 보다 더 많은 작업을 요구하는 이유는 객체지향 기술 자체가 지니는 변화에 효과적으로 대처할 수 있다는 기술적 특징 때문인데요. 어떻게 하면 미래의 변화에 효과적으로 대처할 수 있게 설계를 할 수 있을까요?

분리와 확장을 고려한 설계가 답 입니다.

프로그래밍의 기초 개념 중 관심사의 분리라는게 있는데, 이를 객체지향에 적용해보면 관심이 같은 것끼리는 하나의 객체 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 떨어뜨려 서로 영향을 주지 않도록 분리하는 것이라고 생각할 수 있습니다.

## 커넥션 만들기 추출
### UserDao의 관심사항
지금 만들어져 있는 `UserDao`를 보면 아주 바빠보입니다. `DB Connection`도 만들어야하고, 쿼리도 만들어서 DB에 날려줘야하고, 결과 값을 가공해서 요청한 클라이언트에게 전달도 해줘야합니다.

개중에 또 문제가 되는 부분은 `DB Connection`을 연결하는 부분을 `add`와 `get` 메서드가 모두 사용하면서 중복이 일어나고 있다는 점 입니다.

지금처럼 코드가 많지 않으면 그나마 낫지만 실무에서는 수십 수백군데에서 사용할 수 있는 로직인데요, 모두 중복으로 사용하다가 코드에 수정이라도 생긴다고 생각하면... 끔찍합니다.

이걸 보듯이 하나의 관심사(`DB Connection`)가 여러군데에서 중복되어 있고 다른 관심의 대상과 얽혀있으면, 변경이 일어날 때 끔찍한 일이 발생할 수 있습니다.

### 중복 코드의 메소드 추출
중복되어 사용되고 있는 `DB Connection` 로직을 메소드로 추출해서 관심사를 집중 시켜 보겠습니다.

```java
public class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
		...
    }

    public User get(String id) throws SQLException, ClassNotFoundException {
        Connection c = getConnection();

		...
    }

    private static Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName("org.mariadb.jdbc.Driver");

        return DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/test",
            "testId",
            "password"
        );
    }
}
```

로직을 `DB Connection`에 집중한 관심사로 모아 새로운 메소드를 만들고, 기존 로직에 넣었습니다. 이제 `DB Connection`의 관심에 대한 변화가 생기면 다른 코드에는 영향을 주지 않고 관심이 집중된 코드만 수정하면 됩니다. 관심이 독립적으로 독립하면서 변화에 대응하기 쉬운 코드가 되었습니다.

### 변경사항에 대한 검증
이렇게 리팩토링을 한 후에 `main()`을 통해 검증을 해보면 잘 작동하는걸 볼 수 있습니다. 방금 한 작업은 기능상에는 어떠한 영향도 주지 않았지만 변화에 좀 더 손쉽게 대응할 수 있는 보다 더 깔끔한 코드가 되었습니다.


## 커넥션 만들기의 독립

이번에는 이런 상황을 가정해보겠습니다. `UserDao`의 인기가 너무 많아져서 다른 곳에서도 `UserDao`를 가져다 쓰고 싶어하고 있습니다. 그런데 `DB Connection` 로직만은 외부에 공개하고 싶지가 않은거죠.

이런 경우에는 `UserDao`를 추상 클래스로 만들고 `getConnection`을 추상 메소드로 선언해서, 외부에서 `UserDao`를 상속받게 한 뒤 각자 입맛에 맞게 `getConnection`을 구현하도록 하는 방법을 사용할 수 있습니다. 아예 데이터베이스 연결이라는 관심사 자체를 외부(추상 클래스를 상속한 서브클래스)로 독립시켜버리는거죠.


```java
public abstract class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = getConnection();
		...
    }

    public User get(String id) throws SQLException, ClassNotFoundException {
        Connection c = getConnection();
		...
    }
    public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}


```

<br>

추상 클래스인 `UserDao`를 상속 받아서 `getConnection`만 독립적으로 구현했습니다. 이 방식을 이용하면 `UserDao`에서 코드를 수정할 필요가 없어지고, 새로운 `DB Connection` 방식이 필요하다면 손쉽게 상속 받아서 새롭게 확장하여 구현하면 됩니다.

```java
public class NUserDao extends UserDao {

    @Override
    public Connection getConnection() throws ClassNotFoundException, SQLException {
        // 독립된 DB Connection 구현
        System.out.println("독립적으로 구현!!!");
        
        Class.forName("org.mariadb.jdbc.Driver");

        return DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/test",
            "testId",
            "password"
        );
    }
}

```

이렇게 슈퍼클래스에 기본적인 로직의 흐름을 짜두고, 기능의 일부를 추상 메소드나 오버라이딩이 가능한 메소드 등으로 만든 뒤 서브 클래스에서 필요에 맞게 구현하도록 하는 디자인 패턴을 `템플릿 메소드 패턴` 이라고 합니다.

그리고 서브 클래스의 `getConnection` 처럼 어떤 클래스의 오브젝트를 어떻게 생성할지에 대한 방법을 결정하게 하는 디자인 패턴을 `팩토리 메소드 패턴` 이라고 합니다.

이런 방식으로 서브 클래스에게 구현을 넘기게 되면 `UserDao`는 `DB Connection`에 대해 `Connection` 인터페이스 타입의 오브젝트라는 것 외에는 관심을 두지 않고, 그저 `Connection` 인터페이스에 정의된 메소드를 사용할 뿐 입니다.

그리고 각 서브 클래스는 `Connection` 을 어떤식으로 제공하는지에 관심을 가지고 있는거죠.

이렇게 관심사를 좀 더 분리해봤습니다.

보다 더 깔끔해졌지만 이 방식에도 단점이 있습니다. 우리는 상속을 사용하면서 관심사를 분리했는데, 자바의 클래스는 다중상속을 허용하지 않습니다. 이미 다른 슈퍼클래스를 상속했을 수도 있고 추후에 상속할 가능성도 없지 않은데, 단지 `Connection`을 구현하기 위해 상속을 써먹기에는 아쉬움이 많습니다.

뿐만 아니라 상속관계라는건 어쩔 수 없이 긴밀한 관계를 유지할 수 밖에 없는데요, 서브 클래스는 슈퍼 클래스의 기능을 직접 사용할 수 있기 때문에 슈퍼 클래스에서 변경이 생기면 서브 클래스에도 영향을 끼칠 수 있습니다. 서브 클래스가 많다면 각각의 서브 클래스들을 다 변경해줘야 할 수도 있고... 어디서 많이 본 상황이 펼쳐지죠?

그리고 새로 만든 `DB Connection` 기능을 다른데서 사용할 수 없는 것도 문제가 됩니다. 각자의 방식대로 구헌은 했다지만 동일한 방식으로 `DB Connection` 을 사용할 경우 이를 갖다쓰지 못하고 계속 새로 구현해야하는 경우도 생길 수 있습니다.



# 1.3 DAO의 확장

여러모로 단점이 많이 보이는 상속을 제쳐두고 관심사를 좀 더 확실히 분리해보도록 하겠습니다.

## 클래스의 분리

우리는 `DB Connection`이라는 관심사를 `UserDao`의 다른 관심사와 분리하기 위해서 처음에는 독립된 메소드를 만들었고, 그 다음에는 상속 관계를 가진 클래스로 분리했습니다.

이번에는 좀 더 독립성을 보장하고자 아예 다른 클래스로 만들어 관심사를 분리하겠습니다. `SimpleConnectionMaker` 라는 `DB Connection` 에 대한 관심을 두는 클래스를 만들고, `UserDao` 에서는 새로 만든 클래스를 이용하게 됩니다. 참 쉽죠?

![](https://velog.velcdn.com/images/jomminii/post/7e6427ec-b8e4-454d-bb39-a5ac5eb3c5d1/image.png)


코드를 작성해보겠습니다.

`DB Connection` 기능을 가지는 `SimpleConnectionMaker` 라는 클래스를 생성합니다. 이제 어디서 이걸 상속할 일은 없으니 추상클래스 등으로 만들 필요는 없습니다.

```java
public class SimpleConnectionMaker {
    public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
        Class.forName("org.mariadb.jdbc.Driver");

        return DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/test",
            "testId",
            "password"
        );
    }
}

```

<br>

그리고 `UserDao` 의 생성자에 `SimpleConnectionMaker` 의 오브젝트를 만들어두고 각각의 메소드에서 필요할 때 가져다 쓰면 됩니다.

```java

public class UserDao {

    private SimpleConnectionMaker simpleConnectionMaker;

      public UserDao() {
          simpleConnectionMaker = new SimpleConnectionMaker();
      }
      public void add(User user) throws ClassNotFoundException, SQLException {
          Connection c = simpleConnectionMaker.makeNewConnection();
          ...
      }
    
      public User get(String id) throws SQLException, ClassNotFoundException {
          Connection c = simpleConnectionMaker.makeNewConnection();
          ...
      }
}
```

<br>

이렇게 함으로써 상속으로부터 벗어나기는 했는데 아직도 문제가 있습니다.

기존에 상속을 사용했을 때는 각자의 입맛에 맞게 `getConnection()` 을 확장해서 사용할 수 있었지만 이제는 `UserDao` 의 코드를 바꾸지 않으면 DB 연결 기능을 변경할 수가 없습니다. 변경하기 위해서는 `simpleConnectionMaker = new SimpleConnectionMaker();` 를 바꿔야합니다. 이렇게 되면 다른 곳에서 `UserDao` 를 쓰려고 할 때 `DB Connection` 정보를 알 수 밖에 없습니다.


클래스 분리 후에도 자유롭게 확장 가능하게 하려면 두 가지 문제를 해결해야하는데요, 첫 번째는 메소드가 문제가 됩니다. 지금은 가져다 쓰는 곳이 몇 군데 되지 않아서 괜찮지만 만약 기능을 구현한 `SimpleConnection`의 메소드 이름이 `makeNewConnection` 에서 `createNewConnection` 등으로 바뀌게 된다면, 이 메소드를 사용한 모든 곳을 찾아가서 다 바꿔줘야합니다.


```java
Connection c = simpleConnectionMaker.makeNewConnection();
-> simpleConnectionMaker.createNewConnection();

```

<br>

그리고 두 번째 문제는 `UserDao`가 `DB Connection` 을 해주는 클래스가 어떤 것인지 구체적으로 알고 있어야 한다는 것 입니다. 알고 있어야 한다는 이야기는 기능을 구현한 클래스가 다른 클래스로 바뀌게 되면 그 변화에 맞춰 `UserDao`에도 수정할게 생긴다는 이야기 입니다.


<br>

이 문제들의 근본적인 원인은 `UserDao`가 `DB Connection` 에 대한 정보를 너무 많이 알고 있기 때문인데요, 이 문제를 해결하기 위해 인터페이스를 도입해 보겠습니다.

<br>

## 인터페이스의 도입

인터페이스는 두 개의 클래스를 보다 더 추상적으로 연결시켜 줍니다. `makeConnection` 이라는 기능을 추상화시킨 `ConnectionMaker` 라는 인터페이스를 중간에 두게 되면 `UserDao`는 그 뒤의 구현이 어떻게 되든 모르고 있어도 됩니다. 그저 `ConnectionMaker.makeConnection`이 `DB connection` 의 역할을 해준다는 것만 알고 있으면 되죠.

그리고 구현하는 입장에서는 각자의 입맛에 맞게 `makeConnection`을 구현해 놓기만 하면 됩니다.

이렇게 인터페이스가 중간에 껴주면 각자의 세부 구현에 변화가 생겨도 `UserDao`는 영향을 받지 않게 됩니다.

![](https://velog.velcdn.com/images/jomminii/post/b9a1d5d2-9f12-4af9-91f4-62847a5df0d8/image.png)

코드로 한 번 살펴보죠.

먼저 DB 연결 기능을 구현할 메소드인 `makeConnection` 을 설정해줍니다.
```java
public interface ConnectionMaker {
    Connection makeConnection() throws ClassNotFoundException, SQLException;
}

```

<br>


그리고 나서 `ConnectionMaker` 인터페이스를 구현한 `DconnectionMaker` 를 만듭니다. `DconnectionMaker`는 자신만의 `makeConnection` 을 만들어 클라이언트에게 제공할 수 있게 되었습니다.


```java
public class DConnectionMaker implements ConnectionMaker{

    @Override
    public Connection makeConnection() throws ClassNotFoundException, SQLException {
        // 입맛대로 DB Connection 기능을 구현
        return null;
    }
}

````

<br>

`UserDao`는 이제 DB 연결 기능을 사용하기 위해 직접 구현체에 붙어서 메소드를 사용하지 않아도 됩니다. 연결 기능을 제공해주는 인터페이스인 `ConnectionMaker`에만 붙어서 `add` 메소드에서 사용하고 있습니다.


```java
public class UserDao {

    private ConnectionMaker connectionMaker;

    public UserDao() {
        connectionMaker = new NConnectionMaker();
    }
    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();
		...
}

```

<br>

이제 구현체 메소드의 세부 구현 내용까지는 몰라도 되게 되었는데, 아직 남아있는게 있습니다. 초기에 어떤 클래스의 오브젝트를 사용할지 결정하는 생성자에 어떤 구현체를 사용할지 설정하는 부분이 남아있네요.

이렇게 되면 결국은 `UserDao`가 `ConnectionMaker` 의 어떤 구현체를 사용해야하는지 알아야하기 때문에 두 클래스가 완전히 분리되었다고 말할 수 없겠네요.

그렇다면 어떻게 해야할까요?

```java
    public UserDao() {
        connectionMaker = new NConnectionMaker();
    }
```


<br>


## 관계설정 책임의 분리

짧은 코드지만 아래의 코드 또한 관계설정이라는 뚜렷한 관심사를 가지고 있습니다. 이 관심사도 다른 관심사들과 분리를 해야할 것 같네요.
```java
connectionMaker = new NConnectionMaker();
```


기존의 관계를 보면 `UserDao`는 `ConnectionMaker`만 알고 이를 구현한 메소드를 사용해야할 것 같지만 실제로는 `NconnectionMaker`를 알고 있게 되었는데요, 이젠 알고 싶어도 모르게 책임을 넘기려고 합니다.

![](https://velog.velcdn.com/images/jomminii/post/84b9baa3-4848-4ce9-af00-30e4150cde8f/image.png)

<br>

그럼 이 관계설정의 책임은 누가 가져가는게 좋을까요?
아무래도 `UserDao`를 사용하는 클라이언트가 설정하는게 좋을 것 같습니다.

이제 `UserDao`가 `ConnectionMaker`의 어떤 구현 클래스를 사용하게 될지 결정을 해줘야하는데요, 이는 `UserDao` 오브젝트와 `ConnectionMaker`를 구현한 특정 클래스로부터 만들어진 오브젝트 사이의 관계를 맺어주는걸 의미합니다.

두 클래스 간의 관계가 아닌 두 오브젝트 간의 관계라는걸 이해하는게 중요합니다.  클래스 사이의 관계라는건 코드 안에서 이루어지는 사용과 같은 관계라면 오브젝트 간의 관계라는건 런타임 시 동적으로 맺어진 관계 입니다.

코드에서는 서로를 알지 못했지만 특정 클래스를 구현한 인터페이스를 사용했다면 런타임 시 그 클래스의 오브젝트를 받아서 사용할 수 있게 되죠. 이건 객체지향 프로그램의 다형성이라는 특징 때문에 가능하게 됩니다.


코드로 한 번 살펴보죠.

<br>

먼저 `UserDao`의 생성자에 변화를 주겠습니다. 기존에는 생성자가 어떤 `ConnectionMaker`의 구현체를 사용할지 결정하는 책임까지 졌다면, 수정된 생성자에서는 외부에서 결정된 구현체를 받아서 생성자를 생성하고 있습니다.

인터페이스 구현체는 인터페이스로 받아서 사용할 수 있기 때문에 이런 방식이 가능합니다.

```java
// 기존 생성자
public UserDao() {
    connectionMaker = new DConnectionMaker();
}
```
```java
// 수정된 생성자
public UserDao(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
}

```
<br>

그리고 관계설정 책임은 `UserDao`를 사용하는 `TestMain`에게 넘겼습니다.

`TestMain`은 `ConnectionMaker`의 구현체로 `DconnectionMaker`를 사용할 것을 결정했고, 이 구현체로 만들어진 오브젝트를 `UserDao`에게 전달합니다.

```java
public class TestMain {

    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        UserDao dao = new UserDao(connectionMaker);
        ...
    }
}

```

<br>

`TestMain`이 관계설정 책임을 맡아준 덕분에 `UserDao`는 코드 상에서는 `DConnectionMaker`를 알지 못했지만 런타임에서는 `DconnectionMaker`와 관계를 맺고 구현된 부분을 사용할 수 있게 되었습니다.

![](https://velog.velcdn.com/images/jomminii/post/41c8960c-5744-4f41-a89a-38ae0fa9917f/image.png)

<br>

이 관계를 관계도로 살펴보면 아래처럼 표현할 수 있습니다. `TestMain`은 `DconnectionMaker`를 생성했고, 이를 `UserDao`에 제공하면서 `UserDao`를 생성했고, 그러면서 생성된 `UserDao`를 사용합니다. 그리고 `UserDao`는 `DConnectionMaker`는 모른채 `ConnectionMaker`를 사용하면서 실제로는 구현된 기능을 온전히 누리게 됩니다.

![](https://velog.velcdn.com/images/jomminii/post/4fce7369-5621-4180-9bd3-a315716feae1/image.png)

<br>

## 원칙과 패턴
지금까지 살펴봤던 내용과 관련된 원칙과 패턴에 대해 잠깐 알아보겠습니다.


### 개방 폐쇄 원칙(Open-Closed Principle)
OCP 원칙은 `클래스나 모듈은 확장에는 열려있고 변경에는 닫혀 있어야한다` 라는 원칙인데요, 지금까지 해왔던 리팩토링을 설명하기에 딱 알맞은 원칙 입니다. 인터페이스와 클라이언트를 통해 `UserDao` - `ConnectionMaker`와의 관계를 설정하면서 `UserDao`는 `ConnectionMaker` 의 다양한 구현체들을 사용할 수 있게 되었고(확장), 그러면서도 `UserDao` 에는 변경이 일어나지 않게 하였습니다.

반대로 우리가 처음 만났던 `초난감 DAO`는 `UserDao`는 관심도 없는 `DB Connection`의 구현이 변할 때마다 끊임없이 영향을 받으며 고통 받았습니다.

잘 설계된 구조의 결과물이 느껴지시나요?

<br>

### 높은 응집도와 낮은 결합도


#### 높은 응집도
응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임, 관심사에 집중하고 있다는 걸 의미합니다. 그리고 응집도가 높은 만큼 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 걸 의미하기도 합니다.

예를 들어 처음의 `초난감 DAO`에서는 DB를 연결하는 기능에 수정이 생겼다고 하면 그와 관련된 다른 기능들에 어떤 영향을 끼치는지 쉽게 확인하기 어렵습니다.

반면 관계설정까지 마친 마지막 리팩토링 코드에서 DB 연결 기능이 수정된다고 하면 그냥 `TestMain`에서 변경된 `ConnectionMaker`의 구현체로 교체만하고, 구현체의 이상 유무만 파악하면 됩니다.

DB 연결에 대한 기능은 해당 구현체에만 속해있기 때문이죠. 객체지향의 원리 중 하나인 단일책임원칙(SRP)과도 비슷한 맥락입니다.

<br>

#### 낮은 결합도
결합도라는건 하나의 오브젝트가 변했을 때 다른 오브젝트에 미치는 영향의 정도라고 볼 수 있는데 설계가 잘 되었다면 낮은 결합도가 유지되어야 합니다.

DB 연결 기능에 변화가 생겨도 `UserDao` 에는 큰 영향을 끼치지 않으니 결합도가 낮다고 볼 수 있죠. 중간에 인터페이스가 껴있기 때문에 이 낮은 결합도가 가능해졌습니다.

높은 응집도와 낮은 결합도 이 둘을 유지한다면 객체지향의 원칙을 잘 지켜가고 있다고 볼 수 있습니다.


### 전략 패턴

전략 패턴은 자신의 기능 컨택스트에서 변경이 필요한 기능을 인터페이스를 통해 외부로 분리시키고, 필요에 따라 구체적인 기능을 적용해서 사용할 수 있게 하는 디자인패턴 입니다.

DB 연결 기능 같은 기능을 `DConnectionMaker`나 `NConnectionMaker`처럼 대체가능한 전략으로 두고 필요에 따라 사용합니다.

그리고 `TestMain`과 같은 클라이언트에 대한 역할도 설명하고 있는데 컨택스트를 사용하는 클라이언트는 컨택스트가 사용할 전략을 생성자 등을 통해 제공하는게 일반적 입니다.

리팩토링 결과를 보면 높은 응집도와 낮은 결합도를 가지고 있으며 전략패턴을 사용해서 완벽한 코드가 된 것 같네요.

근데 과연 완벽할까요?

<br>

# 제어의 역전(IoC)

##  오브젝트 팩토리
이전 리팩토링에서 조금 마음에 걸렸던게 있는데요, 바로 `TestMain`이 관계설정이라는 역할까지 하고 있다는 점 입니다. 각자의 관심사에 맞게 응집도를 높이고 결합도를 낮춰야한다고 했는데, `TestMain`은 그저 테스트를 위해 만들어놓은 친구였는데 관계설정의 부담까지 가지게 되었습니다.

이제 이 부담을 덜어주려고 합니다.

### 팩토리

팩토리라는 개념은 객체의 생성 방법을 결정하고, 이에 따라 만들어진 오브젝트를 리턴해주는 클래스를 말하는데요, 이 팩토리 개념을 사용해서 관계설정이라는 기능을 분리시켜 보겠습니다.

먼저 `UserDao`의 관계를 설정해줄 `DaoFactory` 클래스를 만들어줍니다.

정말 딱 `UserDao`와 `ConnectionMaker`와의 관계만을 설정하고, 이 관계로 만들어진 오브젝트를 리턴해줍니다. 깔끔하고 간결하죠?

```java
public class DaoFactory {
    public UserDao userDao() {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        return new UserDao(connectionMaker);
    }
}
```

<br>

`TestMain` 도 바꿔봅니다. 기존에는 관계설정까지 모두 해줬었지만 이제는 `DaoFactory` 에서 설정한대로 만들어진 `UserDao`를 데려와 사용합니다.

```java
// 기존
public static void main(String[] args) throws SQLException, ClassNotFoundException {
    ConnectionMaker connectionMaker = new DConnectionMaker();
    UserDao dao = new UserDao(connectionMaker);
```

```java
// 수정
public static void main(String[] args) throws SQLException, ClassNotFoundException {
    UserDao dao = new DaoFactory().userDao();

```



<br>

### 설계도로서의 팩토리

팩토리가 적용된 관계도는 아래와 같습니다. `UserDao`와 `ConnectionMaker`는 실질적인 로직을 담당하고 있고, `DaoFactory`는 관계설정과 같은 설계도의 역할을 해주고 있습니다.

![](https://velog.velcdn.com/images/jomminii/post/bc72270e-d9bb-4d37-afe4-68466109ef8c/image.png)

각자의 역할을 잘 하면서 깔끔하게 분리게 되었습니다.





## 오브젝트 팩토리의 활용

이전까지는 `UserDao` 하나를 사용할 때만 봤었는데요, 실무에서는 더 많은 Dao 들이 생겨나겠죠. `AccountDao`라는 Dao 가 새로 생겼다고 해보겠습니다.

`AccountDao`에도 똑같이 `DConnectionMaker`를 사용하고 싶은데요, 벌써부터 중복이 눈에 띄죠? 지금은 둘이지만 나중에 더 많은 Dao 들이 생겨난다면... 거기에 `NConnectionMaker`로 바꿀 니즈까지 생긴다면... 하나하나 모두 찾아서 바꿔야하는 불상사가 생깁니다.


```java
public class DaoFactory {
    public UserDao userDao() {
        return new UserDao(new DConnectionMaker());
    }

    public AccountDao accountDao() {
        return new AccountDao(new DConnectionMaker());
    }
}
```

<br>


이 문제는 `초난감 DAO` 초창기에 풀었던 방식인 메소드 추출로 해결할 수 있습니다.

공통된 `new DeconnectionMaker`를 반환해주는 메소드를 정의하고 각 Dao 설정 시점에 메소드를 불러 관계를 설정해줍니다. 이제 수정이 생겨도 `connectionMaker()` 만 수정하면 되겠죠?

```java
public class DaoFactory {
    public UserDao userDao() {
        return new UserDao(connectionMaker());
    }

    public AccountDao accountDao() {
        return new AccountDao(connectionMaker());
    }

    private ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}

```

<br>

## 제어권의 이전을 통한 제어관계 역전
제어의 역전이라는 개념은 말 그대로 프로그램에 대한 제어의 흐름이 반대로 이루어진다는 의미입니다.

기존의 `초난감 DAO`를 보면 모든 제어의 흐름을 `UserDao`가 가지고 있습니다. 자신이 사용할 DB 연결 구현체를 자신이 결정하고, 사용하는 시점도 자신이 결정합니다.

반면에 리팩토링이 된 코드에서는 어떤 구현체를 사용할지 자신이 결정하지 않고 `DaoFactory` 라는 외부 클래스에게 제어권을 넘깁니다. 자신 또한 언제 생성될지 알 수 없고 제어권을 가진 대상에 의해 결정되고 만들어집니다.

프레임워크도 제어의 역전이 적용된 대표적인 기술이라고 볼 수 있습니다. 한 때 라이브러리와 프레임워크의 개념을 처음 접할 때 라이브러리는 내가 코드에서 능동적으로 사용하고, 코드 안에 라이브러리가 있다 이런 식으로 이해했고, 프레임워크는 프레임워크 안에 내 코드가 있어서 프레임워크에 의해 수동적으로 움직이게 된다 라고 이해했는데요.

프레임워크에 의해 수동적으로 움직이게 된다 라는 부분이 제어권이 자신(코드)에게 있지 않고 프레임워크에게 있다는걸 의미합니다. `DaoFactory`도 이런 의미에서 일종의 IoC 컨테이너, 프레임워크의 역할을 하고 있던거죠.

이렇듯 IoC의 개념을 사용하는 이유는 IoC를 적용하게 되면 설계가 깔끔해지고 유연성이 높아지고 이에 따른 확장성도 높아지기 때문입니다.

이런 설계가 가능해지려면 `DaoFactory`와 같은 설계도의 존재가 필요한데, 작은 수준이라면 `DaoFactory`로도 충분하겠지만 본격적으로 사용하고자 하면 스프링과 같은 IoC 프레임워크의 도움이 절실합니다.






# 스프링의 IoC
## 오브젝트 팩토리를 이용한 스프링 IoC
### 애플리케이션 컨텍스트와 설정정보


### DaoFactory를 사용하는 애플리케이션 컨텍스트

## 애플리케이션 컨텍스트의 동작방식


